import { ConstantBackoff, Proto, DaemonLib, LRUBuffer, Websocket, WebsocketBuilder, WebsocketEvents, CustomMessageEvent } from "../src";
import { prototype, Server } from "ws";
import { Message } from "../src/http";
jest.setTimeout(60000)

describe("Testsuite for Websocket", () => {
    const port = 42421;
    const url = `ws://localhost:${port}`;

    let ws: Websocket | undefined;
    let wss: Server | undefined;
    type WsInstanceWithEvent<K extends Event> = { instance: Websocket, event: K };
    test('测试消息', async () => {
        await new Promise<WsInstanceWithEvent<Event> | void>(resolve => {
            let daemonLib: DaemonLib = new DaemonLib('192.168.0.222', 'wcs', {
                proto: Proto.TEXT,
                httpEnable: true,
                httpPort: 9191,
                websocketPort: 8181,
                websocketEnable: true,
                Route: true
            }).OnMessage((ev: any) => {
                let data = ev as CustomMessageEvent;
                data.callback('{\"test\":1234}')
            })
            setTimeout(() => {
                resolve()
            }, 50000);
        }).then(e => {
            console.log('e', e)
        })
    })
    test('测试getclient', async () => {
        await new Promise<WsInstanceWithEvent<Event> | void>(resolve => {
            let daemonLib: DaemonLib = new DaemonLib('192.168.0.222', 'wcs', {
                proto: Proto.TEXT,
                httpEnable: true,
                httpPort: 9191,
                websocketPort: 8181,
                websocketEnable: false,
                Route: true
            })
            daemonLib.GetClients().then(res => {
                console.log('get clients ', res.online)
            })
            setTimeout(() => {
                resolve()
            }, 50000);
        }).then(e => {
            console.log('e', e)
        })
    })
    test('测试文本消息', async () => {
        await new Promise<WsInstanceWithEvent<Event> | void>(resolve => {
            let daemonLib: DaemonLib = new DaemonLib('192.168.0.222', 'wcs', {
                proto: Proto.TEXT,
                httpEnable: true,
                httpPort: 9191,
                websocketPort: 8181,
                websocketEnable: true,
                Route: true
            }).OnMessage((ev: any) => {
                let data = ev as CustomMessageEvent;
                data.callback('{\"test\":1234}')
            })
            daemonLib.Pub('test', 'hello world')
            setTimeout(() => {
                resolve()
            }, 50000);
        }).then(e => {
            console.log('e', e)
        })
    })
});

function delay(ms: number): Promise<void> {
    return new Promise<void>(resolve => {
        setTimeout(() => {
            resolve();
        }, ms);
    })
}

function startServer(port: number): Promise<Server> {
    return new Promise(resolve => {
        const wss = new Server({ port });
        wss.on('listening', () => {
            resolve(wss);
        });
    });
}

function shutdownServerOrTimeout(wss: Server, timeout: number) {
    let timeoutPromise = delay(timeout);
    let shutdownServerPromise = shutdownServer(wss);
    return Promise.race([timeoutPromise, shutdownServerPromise]);
}

function shutdownServer(wss: Server): Promise<void> {
    return new Promise<void>(resolve => {
        wss.addListener("close", () => resolve());
        wss.close();
    });
}

function shutdownClientOrTimeout(ws: Websocket, timeout: number) {
    let timeoutPromise = delay(timeout);
    let shutdownClientPromise = shutdownClient(ws);
    return Promise.race([timeoutPromise, shutdownClientPromise]);
}

function shutdownClient(ws: Websocket): Promise<void> {
    return new Promise<void>(resolve => {
        ws.addEventListener(WebsocketEvents.close, () => resolve());
        ws.close();
    });
}

function onClientConnected(wss: Server): Promise<WebSocket> {
    return new Promise(resolve => {
        wss.on('connection', (client: WebSocket) => {
            resolve(client);
        });
    });
}