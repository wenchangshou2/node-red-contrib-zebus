import { Message } from "./message";
export declare enum Proto {
    BINARY = "binary",
    TEXT = "test"
}
export interface DaemonOptions {
    websocketEnable?: boolean;
    httpEnable?: boolean;
    httpPort?: number;
    websocketPort?: number;
    proto?: Proto;
    Route?: boolean;
}
interface DaemonEventMap {
    message: CustomEvent<CustomMessageEvent>;
}
export declare enum DaemonEvents {
    message = "message"
}
declare type MessageReplyCallback = (message: string) => void;
export interface CustomMessageEvent {
    readonly message: Message;
    readonly callback: MessageReplyCallback;
}
export declare class DaemonLib {
    private websocketConnectStatus;
    private readonly url;
    private readonly name;
    private websocket;
    private websocketPort?;
    private readonly httpPort;
    private readonly proto;
    private readonly eventListeners;
    private readonly httpClient?;
    private readonly httpEnable;
    private onMessageListeners;
    constructor(url: string, name: string, options: DaemonOptions);
    private onOpen;
    private onClose;
    getWebsocketStatus(): Boolean;
    private Register;
    private MessageReployProcess;
    private binaryProcess;
    private textProcess;
    OnMessage(listener: (ev: CustomEvent<CustomMessageEvent>) => any, options?: boolean | EventListenerOptions): DaemonLib;
    private onMessage;
    private configWebsocket;
    AddEventListener<K extends DaemonEvents>(type: K, listener: (ev: DaemonEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends DaemonEvents>(type: K, listener: (ev: DaemonEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    private dispatchEvent;
    private handleEvent;
    Pub(topic: string, body: any): Promise<any>;
    GetClients(): Promise<import("./http").ClientListInfo>;
    PubV2(topic: string, body: any, timeout?: number, defer?: number): Promise<any>;
}
export {};
//# sourceMappingURL=daemon.d.ts.map